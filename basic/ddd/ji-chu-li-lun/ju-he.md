# 聚合

## 聚合

## 1. 概念

其中一個原則：在單個事務中，只允許對一個聚合實例進行修改。

避免一個大聚合，會導致事務失敗。

父聚合：Product可以作為BacklogItem，Release，Sprint這三個聚合的根，關聯ProductId。

這種改造之後，將getter和setter命名具體化，plan，schedule，轉成CQS方法。

## 2. 原則

**一致性**：

* 設計良好的聚合，無論由於何種業務需求發生改變，在單個事務中，聚合中的所有不變條件都是一致的。
* 設計良好的界限上下文，無論哪種情況下，它都保證在一個事務中只修改一個聚合實例。
* 引用聚合和被引用聚合不可以在同一個事務中進行修改。
* 如果你試圖在單個事務中修改多個聚合，這往往意味著此時的一致性邊界是錯誤的。

**通過標誌引用**

* 在調用聚合方法時候，使用資源庫或領域服務來獲取所需要的對象。

![](../../../.gitbook/assets/arrgregate.png)

## 3. 聚合根深入理解

聚合Aggregate，聚合根Aggregate Root

定义了业务领域对象之间的边界，聚合可以看做一个修改数据单元。

> 1. 每个聚合有一个根和一个边界，边界定义了一个聚合内部有哪些实体或值对象，根是聚合内的某个实体；
> 2. 聚合内部的对象之间可以相互引用，但是聚合外部如果要访问聚合内部的对象时，必须通过聚合根开始导航，绝对不能绕过聚合根直接访问聚合内的对象，也就是说聚合根是外部可以保持 对它的引用的唯一元素；
> 3. 聚合内除根以外的其他实体的唯一标识都是本地标识，也就是只要在聚合内部保持唯一即可，因为它们总是从属于这个聚合的；
> 4. 聚合根负责与外部其他对象打交道并维护自己内部的业务规则；
> 5. 基于聚合的以上概念，我们可以推论出从数据库查询时的单元也是以聚合为一个单元，也就是说我们不能直接查询聚合内部的某个非根的对象；
> 6. 聚合内部的对象可以保持对其他聚合根的引用；
> 7. 删除一个聚合根时必须同时删除该聚合内的所有相关对象，因为他们都同属于一个聚合，是一个完整的概念；

